<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Scraper Configuration</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container mt-4">
        <h1>AI-Powered Web Scraper</h1>
        <p>Welcome to the AI-Powered Web Scraper. Configure your scraping task below.</p>
        
        <div class="navigation-links mb-3">
            <a href="{{ url_for('index') }}" class="nav-button active">Basic Scraper</a>
            <a href="{{ url_for('visual_selector') }}" class="nav-button">Visual Selector</a>
            <button id="new-session-btn" class="nav-button" style="float: right; background-color: #6b7280;">New Scraping Session</button>
            <!-- If you had an 'Enhanced Scraper' link, it would go here -->
            <!-- <a href="/enhanced" class="nav-link">Enhanced Scraper with Link Navigation</a> -->
        </div>
        
        <div id="mock-mode-banner" class="alert alert-warning" role="alert" style="display: none;">
            <strong>⚠️ Running in Mock Mode:</strong> AI features are simulated.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close" id="dismiss-mock-banner"></button>
        </div>
        
        <div class="card mb-3" id="api-config-section">
            <div class="card-body">
                <h2 class="card-title">AI Assistant Configuration</h2>
            <div class="form-group">
                <label for="api-url">LM Studio API URL:</label>
                    <div class="input-group">
                        <input type="text" class="form-control" id="api-url" name="api_url" value="{{ api_url if api_url else 'http://localhost:1234/v1' }}" placeholder="e.g., http://localhost:1234/v1">
                        <button type="button" class="btn btn-outline-secondary" id="update-api">Update</button>
                </div>
                    <div class="mt-2">
                        <button type="button" id="auto-discover" class="btn btn-sm btn-info">Auto-discover</button>
                        <button type="button" id="rediscover" class="btn btn-sm btn-info ms-1">Re-test</button>
                </div>
                    <div class="quick-connect-options mt-2">
                    <span>Quick connect:</span>
                        {% for p_url in potential_api_urls %}
                            <button type="button" class="btn btn-sm btn-light quick-connect" data-url="{{ p_url }}">{{ p_url.split(':')[1].replace('//','') }}</button>
                        {% endfor %}
                </div>
                    <div class="form-check mt-2">
                        <input type="checkbox" class="form-check-input" id="use-mock-mode" name="use_mock_mode" {% if is_mock_mode %}checked{% endif %}>
                        <label class="form-check-label" for="use-mock-mode">Use Mock Mode (work offline)</label>
                </div>
                    <div id="wsl-tip" class="form-text">
                        <strong>WSL Tip:</strong> If WSL, try WSL Bridge or Docker Host.
                </div>
                    <div id="api-status" class="mt-2"></div>
                </div>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-body">
                <h2 class="card-title">Step 1: Configure Target Website</h2>
            <form id="scraper-form">
                    <div class="form-group mb-3">
                        <label for="start-url" class="form-label">Start URL:</label>
                        <input type="url" class="form-control" id="start-url" name="start_url" required placeholder="https://example.com">
                </div>

                    <div id="llm-query-section" class="form-group mb-3">
                        <label for="llm-query" class="form-label">Describe what you want to extract (AI-powered):</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="llm-query" name="llm_query" placeholder="e.g., Get the price and availability of this book">
                            <button type="button" class="btn btn-primary" id="generate-selectors">Generate Selectors</button>
                    </div>
                        <div id="llm-status" class="mt-1 form-text"></div>
                </div>

                    <div class="form-group mb-3">
                        <label for="pagination-selector" class="form-label">Pagination Selector (optional):</label>
                        <input type="text" class="form-control" id="pagination-selector" name="pagination_selector" placeholder=".next a::attr(href)">
                        <div id="pagination-test-result" class="mt-1 form-text"></div>
                </div>

                    <div class="form-group mb-3">
                        <label for="page-limit" class="form-label">Maximum Pages to Scrape:</label>
                        <input type="number" class="form-control" id="page-limit" name="page_limit" min="1" value="10" placeholder="Max pages or MAX">
                        <div class="page-limit-buttons mt-1">
                            <button type="button" class="btn btn-sm btn-outline-secondary page-limit-button" data-value="5">5</button>
                            <button type="button" class="btn btn-sm btn-outline-secondary page-limit-button" data-value="10">10</button>
                            <button type="button" class="btn btn-sm btn-outline-secondary page-limit-button" data-value="25">25</button>
                            <button type="button" class="btn btn-sm btn-outline-secondary page-limit-button" data-value="50">50</button>
                            <button type="button" class="btn btn-sm btn-outline-secondary page-limit-button" data-value="100">100</button>
                            <button type="button" class="btn btn-sm btn-danger page-limit-button max-button" data-value="0">MAX</button>
                        </div>
                        <small class="form-text text-muted">Limit pages (use MAX for all).</small>
                </div>

                    <div class="form-group mb-3">
                        <label for="item-container" class="form-label">Item Container Selector (for multiple items):</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="item-container" name="item_container" placeholder="article.product_pod">
                            <button type="button" class="btn btn-outline-secondary test-container">Test Container</button>
                    </div>
                        <small class="form-text text-muted">Selector for the repeating element for each item.</small>
                        <div id="container-test-result" class="mt-1 form-text"></div>
                </div>

                    <h3 class="h5 mt-3">Field Selectors</h3>
                    <div id="selectors-container" class="mb-2">
                        <!-- Initial selector item -->
                        <div class="selector-item input-group mb-2">
                            <input type="text" class="form-control field-name" placeholder="Field name" required>
                            <input type="text" class="form-control field-selector" placeholder="CSS or XPath selector" required>
                            <button type="button" class="btn btn-sm btn-outline-info test-selector">Test</button>
                            <button type="button" class="btn btn-sm btn-outline-danger remove-selector">Remove</button>
                    </div>
                        <div class="test-result form-text mb-2"></div> <!-- Test result below each item -->
                </div>
                    <button type="button" id="add-selector" class="btn btn-success btn-sm mb-3">Add Field</button>

                    <div class="form-group mb-3">
                        <label for="export-format" class="form-label">Export Format:</label>
                        <select id="export-format" name="export_format" class="form-select">
                        <option value="json">JSON</option>
                        <option value="csv">CSV</option>
                    </select>
                </div>

                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" value="" id="render-js-in-spider">
                    <label class="form-check-label" for="render-js-in-spider">
                        Use JavaScript rendering for scraping (slower, for complex sites)
                    </label>
                    </div>

                    <div class="form-group mb-3">
                        <label for="save-path" class="form-label">Save Path:</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="save-path" name="save_path" placeholder="e.g., C:/Users/YourName/Documents/scraped_data.json">
                            <button type="button" id="open-file-dialog" class="btn btn-outline-secondary">Browse</button>
                    </div>
                        <small class="form-text text-muted">Leave empty to display results on screen only.</small>
                </div>

                    <button type="submit" class="btn btn-primary">Start Scraping</button>
            </form>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <h2 class="card-title">Results</h2>
                <div id="results" style="white-space: pre-wrap; background-color: #f8f9fa; padding: 10px; border-radius: 5px;">
                <!-- Results will be displayed here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Ensure this script is loaded after the DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            
            // Function to update API status display
            function updateApiStatusDisplay(data) {
                const apiStatusEl = document.getElementById('api-status');
                const llmStatusEl = document.getElementById('llm-status');
                const mockBannerEl = document.getElementById('mock-mode-banner');
                const generateSelectorsBtn = document.getElementById('generate-selectors');

                // Clear previous classes
                apiStatusEl.className = '';
                llmStatusEl.className = '';

                if (data.success) {
                    if (data.mock_mode) {
                        mockBannerEl.style.display = 'block';
                        apiStatusEl.innerHTML = '⚠ Running in mock mode. AI features simulated.';
                        apiStatusEl.className = 'status-warning';
                        llmStatusEl.innerHTML = '⚠ Using mock AI.';
                        llmStatusEl.className = 'status-warning';
                    } else {
                        mockBannerEl.style.display = 'none';
                        apiStatusEl.innerHTML = `✓ Connected to ${data.api_url || 'API'}.`;
                        apiStatusEl.className = 'status-ok';
                        llmStatusEl.innerHTML = '✓ AI Assistant connected.';
                        llmStatusEl.className = 'status-ok';
                    }
                    if(generateSelectorsBtn) generateSelectorsBtn.disabled = false;
                } else {
                    mockBannerEl.style.display = 'none'; 
                    apiStatusEl.innerHTML = `✗ Connection failed: ${data.error}`;
                    apiStatusEl.className = 'status-error';
                    if (data.tip) apiStatusEl.innerHTML += `<br><small class="status-tip">${data.tip}</small>`;
                    llmStatusEl.innerHTML = '✗ AI Assistant not available.';
                    llmStatusEl.className = 'status-error';
                    if(generateSelectorsBtn) generateSelectorsBtn.disabled = true;
                }
                const useMockCheckbox = document.getElementById('use-mock-mode');
                if (useMockCheckbox) useMockCheckbox.checked = data.mock_mode;
            }

            // Test LLM connection on load
            async function initialConnectionTest() {
            try {
                    const response = await fetch('/api-status'); // Use the /api-status endpoint
                const data = await response.json();
                    updateApiStatusDisplay(data); // Update UI based on initial status
                    if (data.api_url) { // Populate API URL if returned
                        document.getElementById('api-url').value = data.api_url;
                }
            } catch (error) {
                    console.error('Initial connection test error:', error);
                    updateApiStatusDisplay({ success: false, error: 'Could not reach backend for status.', mock_mode: document.getElementById('use-mock-mode').checked });
                }
            }
            initialConnectionTest();
            
            // Function to add a new selector row to the form
            function addSelectorRow(name = '', selectorValue = '') {
                const container = document.getElementById('selectors-container');
                const newItem = document.createElement('div');
                newItem.classList.add('selector-item', 'input-group', 'mb-2');
                newItem.innerHTML = `
                    <input type="text" class="form-control field-name" placeholder="Field name" value="${name}" required>
                    <input type="text" class="form-control field-selector" placeholder="CSS or XPath selector" value="${selectorValue}" required>
                    <button type="button" class="btn btn-sm btn-outline-info test-selector">Test</button>
                    <button type="button" class="btn btn-sm btn-outline-danger remove-selector">Remove</button>
                `;
                const testResultDiv = document.createElement('div');
                testResultDiv.classList.add('test-result', 'form-text', 'mb-2');

                container.appendChild(newItem);
                container.appendChild(testResultDiv);

                newItem.querySelector('.remove-selector').addEventListener('click', function() {
                    newItem.remove();
                    testResultDiv.remove();
                    // Save main page state after removing a selector
                    saveMainPageState();
                });

                newItem.querySelector('.test-selector').addEventListener('click', function() {
                    const fieldNameInput = newItem.querySelector('.field-name');
                    const selectorValueInput = newItem.querySelector('.field-selector');
                    // Pass the actual field name and true for renderJS
                    testContainerOrField(selectorValueInput.value, testResultDiv, false, fieldNameInput.value, true);
                });
            }
            
            // Load selectors from visual tool if present in sessionStorage
            function loadSelectorsFromVisualTool() {
                const dataString = sessionStorage.getItem('visualScraperData');
                const selectorsContainer = document.getElementById('selectors-container');
                
                // Check if we already have saved state for the main page
                const savedMainPageState = sessionStorage.getItem('mainPageState');
                
                // Load the main page state first if it exists
                if (savedMainPageState) {
                    try {
                        const mainPageData = JSON.parse(savedMainPageState);
                        console.log("Restoring from saved mainPageState:", mainPageData);
                        
                        // Clear existing selectors before loading
                        document.querySelectorAll('#selectors-container .selector-item, #selectors-container .test-result').forEach(el => el.remove());
                        
                        // Populate form fields from main page state
                        if (mainPageData.start_url) {
                            document.getElementById('start-url').value = mainPageData.start_url;
                        }
                        if (mainPageData.pagination_selector) {
                            document.getElementById('pagination-selector').value = mainPageData.pagination_selector;
                        }
                        if (mainPageData.item_container) {
                            document.getElementById('item-container').value = mainPageData.item_container;
                        }
                        if (mainPageData.render_js_in_spider !== undefined) {
                            document.getElementById('render-js-in-spider').checked = mainPageData.render_js_in_spider;
                        }
                        if (mainPageData.user_query) {
                            document.getElementById('llm-query').value = mainPageData.user_query;
                        }
                        if (mainPageData.page_limit) {
                            document.getElementById('page-limit').value = mainPageData.page_limit;
                        }
                        if (mainPageData.export_format) {
                            document.getElementById('export-format').value = mainPageData.export_format;
                        }
                        if (mainPageData.save_path) {
                            document.getElementById('save-path').value = mainPageData.save_path;
                        }
                        
                        // Create a map of existing fields for merging
                        const existingFields = new Map();
                        if (mainPageData.fields && mainPageData.fields.length > 0) {
                            mainPageData.fields.forEach(field => {
                                existingFields.set(field.name, field);
                                addSelectorRow(field.name, field.selector);
                            });
                        }
                        
                        // Now check if we have new data from the visual selector
                        if (dataString) {
                            try {
                                const visualData = JSON.parse(dataString);
                                console.log("Found visualScraperData in sessionStorage:", visualData);
                                
                                // Update URL, pagination, container if provided and not already set
                                if (visualData.target_url && !document.getElementById('start-url').value) {
                                    document.getElementById('start-url').value = visualData.target_url;
                                }
                                if (visualData.pagination_selector && !document.getElementById('pagination-selector').value) {
                                    document.getElementById('pagination-selector').value = visualData.pagination_selector;
                                }
                                if (visualData.item_container && !document.getElementById('item-container').value) {
                                    document.getElementById('item-container').value = visualData.item_container;
                                }
                                
                                // Add new fields from visual selector that don't already exist
                                if (visualData.fields && visualData.fields.length > 0) {
                                    visualData.fields.forEach(field => {
                                        if (!existingFields.has(field.name)) {
                                            addSelectorRow(field.name, field.selector);
                                            existingFields.set(field.name, field);
                                        }
                                    });
                                }
                                
                                // Save the merged state
                                saveMainPageState();
                                console.log("Merged visualScraperData with existing state and saved as main page state.");
                            } catch (e) {
                                console.error("Error parsing visualScraperData from sessionStorage:", e);
                            }
                        }
                    } catch (e) {
                        console.error("Error parsing mainPageState from sessionStorage:", e);
                        // If there was an error, but we have visual data, try to load that
                        if (dataString) {
                            processVisualScraperData(dataString);
                } else {
                            addSelectorRow(); // Add a default row
                        }
                    }
                } 
                // If no main page state exists but we have visual data
                else if (dataString) {
                    processVisualScraperData(dataString);
                } 
                // No data at all
                else {
                    // Add one default empty selector row
                    addSelectorRow();
                }
            }
            
            // Helper function to process visual scraper data
            function processVisualScraperData(dataString) {
                try {
                    // Clear existing selectors before loading
                    document.querySelectorAll('#selectors-container .selector-item, #selectors-container .test-result').forEach(el => el.remove());
                    
                    const data = JSON.parse(dataString);
                    console.log("Processing visualScraperData:", data);
                    
                    if (data.target_url) {
                        document.getElementById('start-url').value = data.target_url;
                    }
                    if (data.pagination_selector) {
                        document.getElementById('pagination-selector').value = data.pagination_selector;
                    }
                    if (data.item_container) {
                        document.getElementById('item-container').value = data.item_container;
                    }
                    
                    if (data.fields && data.fields.length > 0) {
                        data.fields.forEach(field => {
                            addSelectorRow(field.name, field.selector);
                        });
                    } else {
                        // If no fields came from visual tool, add one default empty row
                        addSelectorRow();
                    }
                    
                    // Save this data as main page state
                    saveMainPageState();
                    console.log("Processed visualScraperData and saved as main page state.");
                } catch (e) {
                    console.error("Error processing visualScraperData:", e);
                    addSelectorRow(); // Add a default row in case of error
                }
            }
            
            loadSelectorsFromVisualTool(); // Call on page load
            
            // Function to save main page state to sessionStorage
            function saveMainPageState() {
                const mainPageData = {
                    start_url: document.getElementById('start-url').value,
                    pagination_selector: document.getElementById('pagination-selector').value,
                    item_container: document.getElementById('item-container').value,
                    render_js_in_spider: document.getElementById('render-js-in-spider').checked,
                    user_query: document.getElementById('llm-query').value,
                    page_limit: document.getElementById('page-limit').value,
                    export_format: document.getElementById('export-format').value,
                    save_path: document.getElementById('save-path').value,
                    fields: []
                };
                
                // Collect field selectors
                document.querySelectorAll('#selectors-container .selector-item').forEach(item => {
                    const fieldNameInput = item.querySelector('.field-name');
                    const selectorInput = item.querySelector('.field-selector');
                    if (fieldNameInput && selectorInput && fieldNameInput.value && selectorInput.value) {
                        mainPageData.fields.push({
                            name: fieldNameInput.value,
                            selector: selectorInput.value
                        });
                    }
                });
                
                sessionStorage.setItem('mainPageState', JSON.stringify(mainPageData));
                console.log("Saved main page state to sessionStorage");
            }
            
            // Add event listeners to form elements to save state on input
            document.getElementById('start-url').addEventListener('input', saveMainPageState);
            document.getElementById('pagination-selector').addEventListener('input', saveMainPageState);
            document.getElementById('item-container').addEventListener('input', saveMainPageState);
            document.getElementById('render-js-in-spider').addEventListener('change', saveMainPageState);
            document.getElementById('llm-query').addEventListener('input', saveMainPageState);
            document.getElementById('page-limit').addEventListener('input', saveMainPageState);
            document.getElementById('export-format').addEventListener('change', saveMainPageState);
            document.getElementById('save-path').addEventListener('input', saveMainPageState);
            
            // Override addSelectorRow to also save state after adding a row
            const originalAddSelectorRow = addSelectorRow;
            addSelectorRow = function(name = '', selectorValue = '') {
                originalAddSelectorRow(name, selectorValue);
                // Add event listeners to the new inputs to save state on input
                const newInputs = document.querySelectorAll('#selectors-container .selector-item:last-child input');
                newInputs.forEach(input => {
                    input.addEventListener('input', saveMainPageState);
                });
            };

            // Configure API connection
            document.getElementById('update-api').addEventListener('click', async function() {
                const apiUrl = document.getElementById('api-url').value;
                const useMock = document.getElementById('use-mock-mode').checked;
                const apiStatusEl = document.getElementById('api-status');
                const button = this;
                button.disabled = true;
                button.textContent = 'Connecting...';
                apiStatusEl.innerHTML = '<span class="text-info">Testing connection...</span>';
                apiStatusEl.className = 'status-info';

                try {
                    const response = await fetch('/configure-api', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ api_url: apiUrl, use_mock: useMock })
                    });
                    const data = await response.json();
                    updateApiStatusDisplay(data);
            } catch (error) {
                    console.error('Update API error:', error);
                    updateApiStatusDisplay({ success: false, error: 'Failed to send request.', mock_mode: useMock });
                } finally {
                    button.disabled = false;
                    button.textContent = 'Update';
            }
            });

        // Auto-discover button
        document.getElementById('auto-discover').addEventListener('click', async function() {
                const apiStatusEl = document.getElementById('api-status');
                const button = this;
                button.disabled = true;
                button.textContent = 'Discovering...';
                apiStatusEl.innerHTML = '<span class="text-info">Auto-discovering...</span>';
                apiStatusEl.className = 'status-info';
            try {
                const response = await fetch('/configure-api', {
                    method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ auto_discover: true })
                });
                const data = await response.json();
                    updateApiStatusDisplay(data);
                    if (data.success && data.api_url) {
                    document.getElementById('api-url').value = data.api_url;
                }
            } catch (error) {
                    console.error('Auto-discover error:', error);
                     updateApiStatusDisplay({ success: false, error: 'Auto-discovery request failed.', mock_mode: document.getElementById('use-mock-mode').checked });
            } finally {
                    button.disabled = false;
                    button.textContent = 'Auto-discover';
            }
        });
        
        // Re-test connection button
        document.getElementById('rediscover').addEventListener('click', async function() {
                 // This can simply re-trigger the logic of 'update-api' or a specific test endpoint.
                 // For simplicity, let's make it behave like update with current values.
                 document.getElementById('update-api').click();
        });

        // Quick connect buttons
        document.querySelectorAll('.quick-connect').forEach(button => {
            button.addEventListener('click', function() {
                    document.getElementById('api-url').value = this.getAttribute('data-url');
                    document.getElementById('update-api').click(); // Trigger update
            });
        });

        // Generate selectors using the LLM
            const generateSelectorsButton = document.getElementById('generate-selectors');
            if (generateSelectorsButton) {
                generateSelectorsButton.addEventListener('click', async function() {
            const url = document.getElementById('start-url').value;
            const query = document.getElementById('llm-query').value;
                    const llmStatusEl = document.getElementById('llm-status');
                    const button = this;
            
            if (!url || !query) {
                        llmStatusEl.innerHTML = 'Please enter both URL and query.';
                        llmStatusEl.className = 'status-error';
                return;
            }
                    button.disabled = true;
                    button.textContent = 'Generating...';
                    llmStatusEl.innerHTML = 'Asking AI to generate selectors...';
                    llmStatusEl.className = 'status-info';
            
            try {
                const response = await fetch('/generate-selectors', {
                    method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url, query })
                });
                const data = await response.json();
                if (data.success) {
                            llmStatusEl.innerHTML = '✓ Selectors generated successfully!';
                            llmStatusEl.className = 'status-ok';
                            if (data.warning) llmStatusEl.innerHTML += ` <span class="status-warning">(${data.warning})</span>`;
                            
                            // Store existing fields in a map to keep those not overwritten by the new selectors
                            const existingFieldSelectors = new Map();
                            document.querySelectorAll('#selectors-container .selector-item').forEach(item => {
                                const fieldNameInput = item.querySelector('.field-name');
                                const selectorInput = item.querySelector('.field-selector');
                                if (fieldNameInput && selectorInput && fieldNameInput.value) {
                                    existingFieldSelectors.set(fieldNameInput.value, {
                                        name: fieldNameInput.value,
                                        selector: selectorInput.value
                                    });
                                }
                            });
                            
                            // Clear the selectors container to rebuild it
                            document.querySelector('#selectors-container').innerHTML = '';
                            
                            // Update container and pagination from response if provided
                            const selectors = data.selectors;
                    if (selectors.item_container) {
                        document.getElementById('item-container').value = selectors.item_container;
                        delete selectors.item_container;
                    }
                    if (selectors.pagination_selector) {
                        document.getElementById('pagination-selector').value = selectors.pagination_selector;
                        delete selectors.pagination_selector;
                    }
                    
                            // First add the newly generated selectors
                            for (const [fieldName, selectorValue] of Object.entries(selectors)) {
                                addSelectorRow(fieldName, selectorValue);
                                // Remove from existingFieldSelectors if we've just added it
                                existingFieldSelectors.delete(fieldName);
                            }
                            
                            // Now add back any existing selectors that weren't overwritten
                            for (const [fieldName, fieldData] of existingFieldSelectors.entries()) {
                                addSelectorRow(fieldData.name, fieldData.selector);
                            }
                            
                            // Save the updated state
                            saveMainPageState();
                            
                            // Auto-test container and pagination after generation
                            if (document.getElementById('item-container').value) {
                                testContainerOrField(document.getElementById('item-container').value, document.getElementById('container-test-result'), true, null, true);
                            }
                            if (document.getElementById('pagination-selector').value) {
                                testContainerOrField(document.getElementById('pagination-selector').value, document.getElementById('pagination-test-result'), false, null, true);
                            }

                } else {
                            llmStatusEl.innerHTML = `✗ Error generating selectors: ${data.error}`;
                            llmStatusEl.className = 'status-error';
                }
            } catch (error) {
                        console.error('Generate selectors error:', error);
                        llmStatusEl.innerHTML = `✗ Error: ${error.message}`;
                        llmStatusEl.className = 'status-error';
            } finally {
                        button.disabled = false;
                        button.textContent = 'Generate Selectors';
                    }
                });
            }
            
            // Function to test a selector (for container or individual field)
            async function testContainerOrField(selector, resultElement, isContainer, fieldName, renderJS = false) {
                const url = document.getElementById('start-url').value;
                if (!url) {
                    resultElement.textContent = 'Start URL is required to test selectors.';
                    resultElement.className = 'test-result form-text mb-2 status-error';
                    return null;
                }
                if (!selector) {
                    resultElement.textContent = 'Selector is required to test.';
                    resultElement.className = 'test-result form-text mb-2 status-error';
                    return null;
                }

                resultElement.textContent = 'Testing selector...';
                resultElement.className = 'test-result form-text mb-2 status-pending';

                try {
                    const response = await fetch('/test-selector', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            url: url,
                            selector: selector,
                            is_container: isContainer,
                            render_js: renderJS // Send the render_js flag
                        }),
                    });
                    const result = await response.json();
                    let resultHTML = '';
                    
                    if (result.success) {
                        resultElement.className = 'test-result form-text mb-2 status-success';
                        resultHTML = `<p class="mb-1">✓ ${result.message}</p>`;
                        if (isContainer && result.html_snippet_sample) {
                            resultHTML += `<pre class="html-snippet-preview">${escapeHtml(result.html_snippet_sample)}</pre>`;
                        } else if (!isContainer) {
                            if (result.text_content_preview) {
                                resultHTML += `<p class="mb-1"><strong>Text Preview:</strong> ${escapeHtml(result.text_content_preview)}</p>`;
                            }
                            if (result.html_snippet_display) {
                                resultHTML += `<p class="mb-1"><strong>HTML Snippet:</strong></p><pre class="html-snippet-preview">${escapeHtml(result.html_snippet_display)}</pre>`;
                            }
                            // If we have a full html_snippet (for LLM) and a fieldName, add the refine button
                            if (result.html_snippet && fieldName) {
                                // Button creation will happen after setting innerHTML
                            }
                        }
                    } else {
                        resultElement.className = 'test-result form-text mb-2 status-error';
                        resultHTML = `<p>✗ ${result.message || result.error || 'Unknown error'}</p>`;
                    }
                    resultElement.innerHTML = resultHTML;

                    // Now append the refine button if it was created (only for successful non-container tests with snippets and fieldName)
                    if (!isContainer && result.success && result.html_snippet && fieldName) {
                        const refineButton = document.createElement('button');
                        refineButton.type = 'button';
                        refineButton.classList.add('btn', 'btn-sm', 'btn-info', 'mt-2', 'btn-refine-ai');
                        refineButton.textContent = 'Refine with AI';
                        refineButton.dataset.fieldName = fieldName; // Use passed fieldName
                        refineButton.dataset.originalSelector = selector;
                        refineButton.dataset.htmlSnippet = result.html_snippet; 
                        refineButton.addEventListener('click', handleRefineWithAI);
                        resultElement.appendChild(refineButton);
                    }

                } catch (error) {
                    console.error('Selector test error:', error);
                    resultElement.innerHTML = `<p>✗ Error: ${error.message}</p>`;
                    resultElement.className = 'test-result form-text mb-2 status-error';
                }
            }

            // Placeholder for the actual AI refinement logic
            async function handleRefineWithAI(event) {
                const button = event.target;
                const fieldName = button.dataset.fieldName;
                const originalSelector = button.dataset.originalSelector;
                const htmlSnippet = button.dataset.htmlSnippet;
                const llmQueryContext = document.getElementById('llm-query').value;
                const pageUrl = document.getElementById('start-url').value; // Get the page URL
                const resultElement = button.closest('.test-result'); 
                const selectorItemDiv = resultElement.previousElementSibling; // Assuming .selector-item is always before .test-result
                const selectorInput = selectorItemDiv ? selectorItemDiv.querySelector('.field-selector') : null;

                if (!selectorInput) {
                    console.error("Could not find the selector input field for refinement.");
                    alert("Error: Could not find associated selector input field.");
                return;
            }

                console.log("Refine AI clicked for:", { fieldName, originalSelector, htmlSnippet, llmQueryContext });
                
                // Clear previous refinement messages, suggestions, and action buttons
                resultElement.querySelectorAll('.refinement-info, .refinement-error, .refinement-suggestion, .refinement-actions').forEach(el => el.remove());
                
                const statusP = document.createElement('p');
                statusP.className = 'text-info mt-1 refinement-info';
                statusP.textContent = `Asking AI to refine '${fieldName}'...`;
                resultElement.appendChild(statusP);
                button.disabled = true;
                button.textContent = 'Processing...';

            try {
                    const response = await fetch('/refine-selector-via-llm', {
                    method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                            field_name: fieldName,
                            original_selector: originalSelector,
                            html_snippet: htmlSnippet,
                            user_query_context: llmQueryContext,
                            page_url: pageUrl // Send the page URL
                    })
                });
                    const result = await response.json();
                    statusP.remove(); // Remove "Asking AI..." message

                    if (result.success && result.data) {
                        const suggestion = result.data;
                        const autoTest = result.auto_test_result; // Get auto-test result

                        let finalSelector = suggestion.refined_selector;
                        // Construct the display selector as per AI's logic
                        if (suggestion.extraction_method === 'text') {
                            if (!finalSelector.endsWith('::text')) finalSelector += '::text';
                        } else if (suggestion.extraction_method === 'attribute' && suggestion.extraction_detail) {
                            if (!finalSelector.includes('::attr')) finalSelector += `::attr(${suggestion.extraction_detail})`;
                        }

                        const suggestionDiv = document.createElement('div');
                        suggestionDiv.className = 'mt-1 alert alert-info refinement-suggestion'; // Changed to alert-info for now
                        suggestionDiv.innerHTML = `
                            <strong>AI Suggestion (Confidence: ${ (suggestion.confidence * 100).toFixed(0) }%)</strong><br>
                            New Selector: <code>${escapeHtml(finalSelector)}</code><br>
                            Method: ${suggestion.extraction_method} ${suggestion.extraction_detail ? '('+escapeHtml(suggestion.extraction_detail)+')' : ''}<br>
                            Notes: ${escapeHtml(suggestion.notes)}
                        `;
                        
                        // Display auto-test results
                        const autoTestDiv = document.createElement('div');
                        autoTestDiv.className = 'mt-2 auto-test-results';
                        if (autoTest && autoTest.success) {
                            autoTestDiv.innerHTML = `<p class="text-success">✓ Auto-test of AI selector: ${autoTest.message}</p>`;
                            if (autoTest.text_content_preview) {
                                autoTestDiv.innerHTML += `<p>Preview: ${escapeHtml(autoTest.text_content_preview)}</p>`;
                            }
                            suggestionDiv.classList.remove('alert-info');
                            suggestionDiv.classList.add('alert-success'); // Make it green if auto-test is good
                        } else if (autoTest) {
                            autoTestDiv.innerHTML = `<p class="text-danger">✗ Auto-test of AI selector: ${autoTest.message || autoTest.error || 'Failed'}</p>`;
                            suggestionDiv.classList.remove('alert-info');
                            suggestionDiv.classList.add('alert-warning'); // Make it yellow/orange if auto-test failed
                } else {
                            autoTestDiv.innerHTML = `<p class="text-warning">Auto-test results not available.</p>`;
                        }
                        suggestionDiv.appendChild(autoTestDiv);
                        resultElement.appendChild(suggestionDiv);

                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'mt-2 refinement-actions';

                        const acceptBtn = document.createElement('button');
                        acceptBtn.type = 'button';
                        acceptBtn.className = 'btn btn-sm btn-success me-2';
                        acceptBtn.textContent = 'Accept Suggestion';
                        acceptBtn.onclick = () => {
                            selectorInput.value = finalSelector;
                            suggestionDiv.remove();
                            actionsDiv.remove();
                            button.disabled = false;
                            button.textContent = 'Refine with AI';
                            
                            // Save state after accepting a refined selector
                            saveMainPageState();
                            
                            // Optionally, re-test the accepted selector immediately by calling testContainerOrField again
                            // testContainerOrField(finalSelector, resultElement, false, fieldName, true);
                        };

                        // Disable Accept button if auto-test failed or found no results
                        if (!autoTest || !autoTest.success || autoTest.match_count === 0) {
                            acceptBtn.disabled = true;
                            acceptBtn.title = "Accept disabled: AI's suggested selector failed live test or found no results.";
                            if (autoTest && autoTest.match_count === 0) {
                                autoTestDiv.innerHTML += `<p class="text-danger"><strong>Warning:</strong> AI selector found 0 matches on the live page.</p>`;
                            }
                        }

                        const discardBtn = document.createElement('button');
                        discardBtn.type = 'button';
                        discardBtn.className = 'btn btn-sm btn-secondary';
                        discardBtn.textContent = 'Discard';
                        discardBtn.onclick = () => {
                            suggestionDiv.remove();
                            actionsDiv.remove();
                            button.disabled = false;
                            button.textContent = 'Refine with AI';
                        };

                        actionsDiv.appendChild(acceptBtn);
                        actionsDiv.appendChild(discardBtn);
                        resultElement.appendChild(actionsDiv);

                } else {
                        const errorP = document.createElement('p');
                        errorP.className = 'text-danger mt-1 refinement-error';
                        errorP.textContent = `AI Refinement Error: ${result.error || 'Unknown error'}`;
                        if (result.raw_response) {
                            errorP.innerHTML += `<br><small>Raw: ${escapeHtml(result.raw_response.substring(0,100))}...</small>`;
                        }
                        resultElement.appendChild(errorP);
                        button.disabled = false; // Re-enable on error
                        button.textContent = 'Refine with AI';
                }
            } catch (error) {
                    console.error("Error calling /refine-selector-via-llm:", error);
                    statusP.remove(); // Ensure status is removed if it hasn't been
                    const errorP = document.createElement('p');
                    errorP.className = 'text-danger mt-1 refinement-error';
                    errorP.textContent = `Network or Server Error during AI refinement: ${error.message}`;
                    resultElement.appendChild(errorP);
                    button.disabled = false; // Re-enable on error
                    button.textContent = 'Refine with AI';
                } 
                // No finally block needed here as button re-enabling is handled in specific paths
            }

            // Utility function to escape HTML for display in <pre>
            function escapeHtml(unsafe) {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

        // Test container selector
            const testContainerButton = document.querySelector('.test-container');
            if(testContainerButton) {
                testContainerButton.addEventListener('click', function() {
                    const selectorValue = document.getElementById('item-container').value;
                    const resultDiv = document.getElementById('container-test-result');
                    testContainerOrField(selectorValue, resultDiv, true, null, true); // Pass null for fieldName, true for renderJS
                });
            }
            
            // Add selector button functionality (ensure this is compatible with loadSelectorsFromVisualTool)
            document.getElementById('add-selector').addEventListener('click', function() {
                addSelectorRow();
            });

            // Initial remove button for the first static row (if it exists and needs dynamic handling)
            // This needs to ensure it doesn't conflict with rows added by loadSelectorsFromVisualTool
            // The addSelectorRow function now handles its own remove buttons, so this might only be needed if the initial row is truly static HTML.
            // For simplicity, let's assume all rows are handled by addSelectorRow or similar dynamic logic.
            // If your initial row in HTML doesn't have its listeners attached by addSelectorRow, it would need separate handling.
            // To ensure consistency, the loadSelectorsFromVisualTool function clears all and then re-adds,
            // or adds a default one if nothing came from sessionStorage.
            // So, the '#add-selector' button is the primary way to add rows manually after page load.

            // Handle form submission for scraping
        document.getElementById('scraper-form').addEventListener('submit', async function(e) {
            e.preventDefault();
            const url = document.getElementById('start-url').value;
                const formSelectors = {};
            let hasErrors = false;
            
                document.querySelectorAll('#selectors-container .selector-item').forEach(item => {
                    const fieldNameInput = item.querySelector('.field-name');
                    const selectorInput = item.querySelector('.field-selector');
                    const fieldName = fieldNameInput.value;
                    const selectorValue = selectorInput.value;
                    
                    fieldNameInput.classList.remove('is-invalid');
                    selectorInput.classList.remove('is-invalid');
                
                    if (!fieldName || !selectorValue) {
                        if (!fieldName) fieldNameInput.classList.add('is-invalid');
                        if (!selectorValue) selectorInput.classList.add('is-invalid');
                    hasErrors = true;
                    } else {
                        formSelectors[fieldName] = selectorValue;
                }
            });
            
                const resultsDiv = document.getElementById('results');
            if (hasErrors) {
                    resultsDiv.innerHTML = '<div class="alert alert-danger">Please fill in all field names and selectors.</div>';
                return;
            }
            
            const itemContainer = document.getElementById('item-container').value;
                if (itemContainer) formSelectors['item_container'] = itemContainer;
            const paginationSelector = document.getElementById('pagination-selector').value;
                if (paginationSelector) formSelectors['pagination_selector'] = paginationSelector;
                
                // Save the form state before submitting
                saveMainPageState();
                
                resultsDiv.innerHTML = '<div class="alert alert-info">Scraping in progress...</div>';
                const scrapeButton = this.querySelector('button[type="submit"]');
                    scrapeButton.disabled = true;
                    scrapeButton.textContent = 'Scraping...';
                
                try {
                const response = await fetch('/scrape', {
                    method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        start_url: url,
                            selectors: formSelectors,
                            export_format: document.getElementById('export-format').value,
                            save_path: document.getElementById('save-path').value,
                            page_limit: parseInt(document.getElementById('page-limit').value) || 0,
                            render_js_in_spider: document.getElementById('render-js-in-spider').checked
                    })
                });
                const data = await response.json();
                if (data.success) {
                        let resultHTML = `<div class="alert alert-success">Found ${data.item_count} items.`;
                    if (data.saved_to_file) {
                            resultHTML += ` Saved to: <strong>${data.file_path}</strong>`;
                        }
                        resultHTML += '</div>';
                        if (data.data && data.data.length > 0) {
                             resultHTML += `<pre>${JSON.stringify(data.data, null, 2)}</pre>`;
                        } else if (!data.saved_to_file) {
                            resultHTML += '<p>No data returned, or data was empty.</p>';
                        }
                        resultsDiv.innerHTML = resultHTML;
                } else {
                        resultsDiv.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                }
            } catch (error) {
                    console.error('Scraping submission error:', error);
                    resultsDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
                } finally {
                    scrapeButton.disabled = false;
                    scrapeButton.textContent = 'Start Scraping';
                }
            });

            // Save path helpers
            const exportFormatSelect = document.getElementById('export-format');
            const savePathInput = document.getElementById('save-path');
            if(exportFormatSelect && savePathInput) {
                exportFormatSelect.addEventListener('change', function() {
                    const currentPath = savePathInput.value;
                    if (currentPath) {
                        let pathWithoutExt = currentPath.replace(/\.(json|csv)$/i, '');
                        savePathInput.value = `${pathWithoutExt}.${this.value}`;
            }
        });
            }
            
            // File dialog helper
            const openFileDialogButton = document.getElementById('open-file-dialog');
            if(openFileDialogButton) {
                openFileDialogButton.addEventListener('click', function() {
                    // This is a placeholder. True file dialogs require more complex solutions
                    // or backend interaction if you need server-side browsing.
                    // For now, it's a conceptual button.
                    alert("Please manually enter the full path for saving the file. For example: C:/scraped_data/output.json or /home/user/output.csv");
        });
            }

            // Page limit buttons
        document.querySelectorAll('.page-limit-button').forEach(button => {
            button.addEventListener('click', function() {
                document.getElementById('page-limit').value = this.getAttribute('data-value');
                    // Save state after changing page limit
                    saveMainPageState();
                });
            });
            
            // Dismiss mock banner
            const dismissMockBannerButton = document.getElementById('dismiss-mock-banner');
            if(dismissMockBannerButton) {
                 dismissMockBannerButton.addEventListener('click', function() {
                    document.getElementById('mock-mode-banner').style.display = 'none';
                });
            }
            
            // New Scraping Session button
            document.getElementById('new-session-btn').addEventListener('click', function() {
                if (confirm('This will clear all current selectors and form data. Start a new scraping session?')) {
                    // Clear all sessionStorage data related to our app
                    sessionStorage.removeItem('mainPageState');
                    sessionStorage.removeItem('visualScraperData');
                    sessionStorage.removeItem('visualSelectorUrl');
                    sessionStorage.removeItem('visualSelectorFieldSelectors');
                    sessionStorage.removeItem('visualSelectorPaginationSelector');
                    sessionStorage.removeItem('visualSelectorItemContainerSelector');
                    
                    // Reset the form
                    document.getElementById('start-url').value = '';
                    document.getElementById('pagination-selector').value = '';
                    document.getElementById('item-container').value = '';
                    document.getElementById('render-js-in-spider').checked = false;
                    document.getElementById('llm-query').value = '';
                    document.getElementById('page-limit').value = '10';
                    document.getElementById('export-format').value = 'json';
                    document.getElementById('save-path').value = '';
                    
                    // Clear the results area
                    document.getElementById('results').innerHTML = '';
                    
                    // Clear all test results
                    document.getElementById('pagination-test-result').innerHTML = '';
                    document.getElementById('container-test-result').innerHTML = '';
                    
                    // Clear all selector rows and add a single empty one
                    const selectorsContainer = document.getElementById('selectors-container');
                    selectorsContainer.innerHTML = '';
                    addSelectorRow();
                    
                    // Provide feedback
                    alert('New scraping session started! All data has been reset.');
                }
            });
        });
    </script>
</body>
</html> 